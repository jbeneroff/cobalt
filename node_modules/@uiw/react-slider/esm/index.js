import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _excluded = ["prefixCls", "value", "min", "max", "dots", "step", "disabled", "progress", "tooltip", "className", "marks", "renderMarks", "vertical", "onChange"];
import React, { useEffect, useState } from 'react';
import Dots from './Dots';
import "./style/index.css";
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
export default function Slider(props) {
  var {
    prefixCls = 'w-slider',
    value = 0,
    min = 0,
    max = 100,
    dots = false,
    step = 1,
    disabled = false,
    progress = true,
    tooltip = false,
    className,
    marks,
    renderMarks,
    vertical,
    onChange
  } = props,
      other = _objectWithoutPropertiesLoose(props, _excluded);

  var bar = React.useRef(null);
  var slider = React.useRef(null);
  var indexBar = React.useRef();
  var startX = React.useRef();
  var curValue = React.useRef();
  var barWidth = React.useRef();
  var barOffsetLeft = React.useRef();
  var move = React.useRef();
  var [arrValue, setArrValue] = useState(Array.isArray(value) ? value : [value]);
  useEffect(() => setArrValue(Array.isArray(value) ? value : [value]), [value]);

  other.onClick = evn => {
    if (move.current !== undefined) {
      return;
    }

    var markOffset = slider.current.getBoundingClientRect();
    var vals = getWidthToValue(evn[vertical ? 'clientY' : 'clientX'] - markOffset[vertical ? 'y' : 'x']);
    var curr = getRangeValue(vals);
    handleChange(curr);
  };

  function getRangeValue(val) {
    if (!Array.isArray(value)) {
      return Array.isArray(val) ? val : [val];
    }

    var newData = [...arrValue];
    var val1 = newData[0];
    var val2 = newData[1];

    if (val1 < val2 && val1 > val || val1 > val2 && val1 < val) {
      newData[0] = val;
    }

    if (val1 < val2 && val2 < val || val1 > val2 && val2 > val) {
      newData[1] = val;
    }

    if (val1 > val && val2 < val) {
      var half = val2 + (val1 - val2) / 2;

      if (half >= val) {
        newData[1] = val;
      }

      if (half < val) {
        newData[0] = val;
      }
    }

    if (val2 > val && val1 < val) {
      var _half = val1 + (val2 - val1) / 2;

      if (_half >= val) {
        newData[0] = val;
      }

      if (_half < val) {
        newData[1] = val;
      }
    }

    return newData;
  }

  function handleChange(val) {
    setArrValue([...val]);
    onChange && onChange(arrValue.length === 1 ? val[0] : val);
  }

  function getWidthToValue(width) {
    var equal = (max - min) / step;
    var percent = 0;

    if (slider.current) {
      percent = width / slider.current[vertical ? 'clientHeight' : 'clientWidth'] * 100;
    }

    if (percent <= 0) {
      percent = 0;
    }

    if (percent >= 100) {
      percent = 100;
    }

    var num = equal * (percent / 100) + 0.5;
    var numFloor = Math.floor(num);
    var vals = numFloor * step + min;
    return vals;
  }

  function onHandleBtnDown(idx, env) {
    if (disabled) {
      return;
    }

    indexBar.current = idx;
    move.current = true;
    startX.current = env[vertical ? 'clientY' : 'clientX'];

    if (bar.current) {
      barWidth.current = bar.current[vertical ? 'clientHeight' : 'clientWidth'];
      barOffsetLeft.current = bar.current[vertical ? 'offsetTop' : 'offsetLeft'];
    }

    var vals = [...arrValue];

    if (Array.isArray(value)) {
      barWidth.current = indexBar.current === 1 && vals[1] > vals[0] || indexBar.current !== 1 && vals[0] > vals[1] ? barWidth.current + barOffsetLeft.current : barOffsetLeft.current;
    }

    window.addEventListener('mousemove', onDragging);
    window.addEventListener('mouseup', onDragEnd);
  }

  function onDragging(env) {
    if (!move.current) {
      return;
    }

    var vals = [...arrValue];
    var valueToWidth = getWidthToValue(env[vertical ? 'clientY' : 'clientX'] - startX.current + barWidth.current);

    if (valueToWidth !== curValue.current) {
      vals[indexBar.current] = valueToWidth;

      var _barStyl = getStyle(vals);

      if (bar.current) {
        bar.current.style[vertical ? 'top' : 'left'] = _barStyl.left;
        bar.current.style[vertical ? 'bottom' : 'right'] = _barStyl.right;
      }

      handleChange(vals);
      curValue.current = valueToWidth;
    }
  }

  function onDragEnd() {
    move.current = undefined;
    window.removeEventListener('mousemove', onDragging, false);
    window.removeEventListener('mouseup', onDragEnd, false);
  }

  var stepArray = () => {
    var equal = (max - min) / step;
    var stepWidth = 100 * step / (max - min);
    var result = [0];

    for (var i = 1; i < equal; i += 1) {
      result.push(i * stepWidth);
    }

    result.push(100);
    return result;
  };

  function getValueToPercent(vals) {
    return (vals - min) * 100 / (max - min);
  }

  function getStyle(val) {
    val = val || arrValue;
    var barStyl = {
      left: '0%',
      right: '100%'
    };

    if (!Array.isArray(value)) {
      barStyl.right = 100 - getValueToPercent(val[0]) + "%";
    } else {
      var leftValue = val[0] > val[1] ? val[1] : val[0];
      var rightValue = val[0] > val[1] ? val[0] : val[1];
      barStyl.left = getValueToPercent(leftValue) + "%";
      barStyl.right = 100 - getValueToPercent(rightValue) + "%";
    }

    return barStyl;
  }

  function getLabelValue(val) {
    if (marks && marks !== true && marks[val] && marks[val].label) {
      return marks[val].label;
    } else if (marks && marks !== true && marks[val] && typeof marks[val] === 'string') {
      return marks[val];
    } else if (renderMarks && typeof renderMarks === 'function' && renderMarks(val)) {
      return renderMarks(val);
    }

    return val;
  }

  var barStyl = getStyle();

  if (disabled) {
    delete other.onClick;
  }

  return /*#__PURE__*/_jsxs("div", _extends({
    ref: slider,
    className: [prefixCls, className, disabled ? 'disabled' : null, marks ? prefixCls + "-with-marks" : null, vertical ? prefixCls + "-vertical" : null].filter(Boolean).join(' ').trim()
  }, other, {
    children: [/*#__PURE__*/_jsx("div", {
      ref: bar,
      className: prefixCls + "-bar",
      style: _extends({
        [vertical ? 'top' : 'left']: barStyl.left,
        [vertical ? 'bottom' : 'right']: barStyl.right
      }, progress !== true ? {
        backgroundColor: progress || 'initial'
      } : {})
    }), [...arrValue].map((item, idx) => {
      var lleftPostion = getValueToPercent(item);
      return /*#__PURE__*/_jsx("div", {
        className: prefixCls + "-handle",
        onMouseDown: evn => onHandleBtnDown(idx, evn),
        style: {
          [vertical ? 'top' : 'left']: lleftPostion + "%"
        },
        children: (tooltip || tooltip === false) && /*#__PURE__*/_jsx("div", {
          className: [prefixCls + "-tooltip", tooltip ? 'open' : null].filter(Boolean).join(' ').trim(),
          children: getLabelValue(item)
        })
      }, idx);
    }), dots && /*#__PURE__*/_jsx(Dots, {
      prefixCls: prefixCls,
      min: min,
      step: step,
      marks: marks,
      vertical: !!vertical,
      data: stepArray(),
      markRender: function markRender(stepValue, mark) {
        if (mark === void 0) {
          mark = {};
        }

        if (!mark) {
          return /*#__PURE__*/_jsxs("div", {
            children: [" ", getLabelValue(stepValue), " "]
          });
        }

        var other = typeof mark === 'object' ? mark : {};
        delete other.label;
        return /*#__PURE__*/_jsxs("div", _extends({}, other, {
          children: [" ", getLabelValue(stepValue), " "]
        }));
      }
    })]
  }));
}
//# sourceMappingURL=index.js.map