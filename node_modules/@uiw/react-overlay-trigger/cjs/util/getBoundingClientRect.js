"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault")["default"];

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = getBoundingClientRect;

var _utils = require("@uiw/utils");

var _getStyleComputedProperty = _interopRequireDefault(require("./getStyleComputedProperty"));

var _getBordersSize = _interopRequireDefault(require("./getBordersSize"));

var _getWindowSizes = _interopRequireDefault(require("./getWindowSizes"));

var _getClientRect = _interopRequireDefault(require("./getClientRect"));

var _isIE = _interopRequireDefault(require("./isIE"));

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11

  try {
    if ((0, _isIE["default"])(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = (0, _utils.getScroll)(element, true);
      var scrollLeft = (0, _utils.getScroll)(element);
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    } // eslint-disable-next-line

  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  }; // subtract scrollbar size from sizes

  var sizes = element.nodeName === 'HTML' ? (0, _getWindowSizes["default"])(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;
  result.offsetLeft = element.offsetLeft || element.scrollLeft || 0;
  result.offsetTop = element.offsetTop || element.offsetTop || 0; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons

  if (horizScrollbar || vertScrollbar) {
    var styles = (0, _getStyleComputedProperty["default"])(element);
    horizScrollbar -= (0, _getBordersSize["default"])(styles, 'x');
    vertScrollbar -= (0, _getBordersSize["default"])(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return (0, _getClientRect["default"])(result);
}

module.exports = exports.default;
//# sourceMappingURL=getBoundingClientRect.js.map