import _extends from "@babel/runtime/helpers/extends";
import React from 'react';
import ReactDOM from 'react-dom';
import { randomid } from '@uiw/utils';
import Container from './Container';
import "./style/index.css";
import { jsx as _jsx } from "react/jsx-runtime";
var notifys = {};
var notifysDom = {};

function NotificationCreate(props, type) {
  if (type === void 0) {
    type = 'open';
  }

  if (!props.placement) {
    props.placement = 'topRight';
  }

  props.type = type;

  if (!props.icon && props.icon !== null) {
    switch (props.type) {
      case 'success':
        props.icon = 'circle-check';
        break;

      case 'warning':
        props.icon = 'warning';
        break;

      case 'info':
        props.icon = 'information';
        break;

      case 'error':
        props.icon = 'circle-close';
        break;

      default:
        break;
    }
  }

  switch (props.type) {
    case 'info':
      props.type = 'primary';
      break;

    case 'error':
      props.type = 'danger';
      break;

    default:
      break;
  }

  if (props.placement && !notifys[props.placement]) {
    var div = document.createElement('div');
    document.body.appendChild(div);
    div.className = ['w-notify-warpper', props.placement].filter(Boolean).join(' ').trim();
    notifysDom[props.placement] = div;
    notifys[props.placement] = ReactDOM.render( /*#__PURE__*/_jsx(Container, {}), div);
  }

  if (props.duration !== null) {
    props.duration = (props.duration || 4.5) * 1000;
  }

  if (notifys[props.placement]) {
    notifys[props.placement].create(_extends({}, props, {
      duration: props.duration,
      key: randomid(),

      willUnmount(nprops, notifysChild) {
        if (!nprops) return;
        nprops.onClose && nprops.onClose();
        var keys = Object.keys(notifysChild[props.placement]);

        if (keys.length === 0 && notifys[props.placement]) {
          delete notifys[props.placement];

          if (notifysDom[props.placement]) {
            document.body.removeChild(notifysDom[props.placement]);
          }
        }
      }

    }));
  }
}

['open', 'success', 'warning', 'info', 'error'].forEach(type => {
  NotificationCreate[type] = function (options) {
    if (options === void 0) {
      options = {};
    }

    return NotificationCreate(options, type);
  };
});
export default NotificationCreate;
//# sourceMappingURL=index.js.map