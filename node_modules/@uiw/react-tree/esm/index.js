import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _excluded = ["prefixCls", "icon", "data", "openKeys", "selectedKeys", "defaultExpandAll", "showLine", "iconAnimation", "isSelected", "checkStrictly", "multiple", "onExpand", "onSelected", "className", "autoExpandParent", "renderTitle"];
import React, { useEffect, useState } from 'react';
import { noop } from '@uiw/utils';
import TreeNode from './TreeNode';
import "./style/index.css";
import { jsx as _jsx } from "react/jsx-runtime";

/**
 * a contains b
 * @param {Array} a
 * @param {Array} b
 */
var isContained = (a, b) => {
  if (!(a instanceof Array) || !(b instanceof Array)) return false;
  if (a.length < b.length) return false;
  var aStr = a.toString();

  for (var i = 0, len = b.length; i < len; i += 1) {
    if (aStr.indexOf(b[i]) === -1) return false;
  }

  return true;
};

export var getChildKeys = function getChildKeys(childs, result) {
  if (childs === void 0) {
    childs = [];
  }

  if (result === void 0) {
    result = [];
  }

  childs.forEach(item => {
    result.push(item.key);

    if (item.children && item.children.length > 0) {
      result = result.concat(getChildKeys(item.children));
    }
  });
  return result;
};

var getParentKeys = function getParentKeys(childs, result) {
  if (childs === void 0) {
    childs = {};
  }

  if (result === void 0) {
    result = [];
  }

  if (childs.key) {
    result.push(childs.key);
  }

  if (childs.parent) {
    result = getParentKeys(childs.parent, result);
  }

  return result;
};

var getParentSelectKeys = function getParentSelectKeys(childs, selectedKeys, result) {
  if (childs === void 0) {
    childs = {};
  }

  if (selectedKeys === void 0) {
    selectedKeys = [];
  }

  if (result === void 0) {
    result = [];
  }

  if (childs.key && childs.children && isContained(selectedKeys, getChildKeys(childs.children))) {
    result.push(childs.key);

    if (childs.parent && !childs.parent.parent) {
      if (isContained(selectedKeys, getChildKeys(childs.children))) {
        selectedKeys = selectedKeys.concat(result);
      }

      if (isContained(selectedKeys, getChildKeys(childs.parent.children))) {
        result.push(childs.parent.key);
      }
    }
  }

  if (childs.parent) {
    result = getParentSelectKeys(childs.parent, selectedKeys, result);
  }

  return result;
};

export default function Tree(props) {
  var {
    prefixCls = 'w-tree',
    icon = 'caret-right',
    data = [],
    openKeys = [],
    selectedKeys = [],
    defaultExpandAll = false,
    showLine = false,
    iconAnimation = true,
    isSelected = true,
    checkStrictly = false,
    multiple = false,
    onExpand = noop,
    onSelected = noop,
    className,
    renderTitle
  } = props,
      elementProps = _objectWithoutPropertiesLoose(props, _excluded);

  var [curOpenKeys, setCurOpenKeys] = useState(openKeys);
  var [curSelectedKeys, setCurSelectedKeys] = useState(selectedKeys); // useEffect(() => setCurOpenKeys(openKeys), [openKeys]);
  // useEffect(() => setCurSelectedKeys(selectedKeys), [selectedKeys]);

  useEffect(() => {
    var arrOpenKeys = getChildKeys(data);

    if (defaultExpandAll) {
      setCurOpenKeys(arrOpenKeys);
    }
  }, []);
  var cls = [className, prefixCls, showLine ? prefixCls + "-line" : null].filter(Boolean).join(' ').trim();

  function onItemClick(item, evn) {
    if (!item.children) {
      return;
    } // const { onExpand } = this.props;
    // const { openKeys } = this.state;


    var currentKeys = [...curOpenKeys];
    var key = currentKeys.find(v => v === item.key);
    var cls = evn.currentTarget.className.replace(/(\s)open/g, '');
    var expanded = false;

    if (!key && item.key) {
      currentKeys.push(item.key);
      evn.currentTarget.className = [cls, 'open'].filter(Boolean).join(' ').trim();
      expanded = true;
    } else {
      currentKeys = currentKeys.filter(v => v !== item.key);
      evn.currentTarget.className = cls;
    }

    setCurOpenKeys(currentKeys);
    onExpand && onExpand(item.key, expanded, item, evn);
  }

  function onItemSelected(item, evn) {
    // const { onSelected, multiple, checkStrictly } = this.props;
    var selKeys = [...curSelectedKeys];
    var findKey = selKeys.find(v => v === item.key);
    var selected = false;

    if (!findKey) {
      selected = true;
      selKeys.push(item.key);
    } else {
      selKeys = selKeys.filter(v => v !== item.key);
    }

    if (checkStrictly) {
      if (!findKey) {
        selKeys = selKeys.concat(getChildKeys(item.children).filter(val => selKeys.indexOf(val) === -1));
        selKeys = selKeys.concat(getParentSelectKeys(item, selKeys));
        selKeys = Array.from(new Set(selKeys)); // Remove duplicates.
      } else {
        selKeys = selKeys.filter(val => getChildKeys(item.children).indexOf(val) === -1);
        selKeys = selKeys.filter(val => getParentKeys(item.parent).indexOf(val) === -1);
      }
    }

    if (!multiple) {
      selKeys = !findKey ? [item.key] : [];
    }

    setCurSelectedKeys(selKeys);
    onSelected && onSelected(selKeys, item.key, selected, item, evn);
  }

  return /*#__PURE__*/_jsx("div", _extends({
    className: cls
  }, elementProps, {
    children: /*#__PURE__*/_jsx(TreeNode, {
      icon,
      iconAnimation,
      isSelected,
      openKeys: curOpenKeys,
      selectedKeys: curSelectedKeys,
      prefixCls,
      renderTitle,
      onItemClick: onItemClick,
      onItemSelected: onItemSelected,
      data: data,
      level: 1
    })
  }));
}
//# sourceMappingURL=index.js.map