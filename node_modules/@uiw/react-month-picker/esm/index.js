import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutPropertiesLoose from "@babel/runtime/helpers/objectWithoutPropertiesLoose";
var _excluded = ["prefixCls", "format", "onChange", "className", "popoverProps", "pickerCaptionProps", "allowClear", "monthLabel"];
import React, { useEffect, useMemo, useState } from 'react';
import Input from '@uiw/react-input';
import Popover from '@uiw/react-popover';
import Button from '@uiw/react-button';
import formatter from '@uiw/formatter';
import { DatePickerMonth, DatePickerYear, DatePickerCaption } from '@uiw/react-date-picker';
import "./style/index.css";
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
var MONTH_LABEL = ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'];
export default function MonthPicker(props) {
  var {
    prefixCls = 'w-monthpicker',
    format = 'YYYY/MM',
    onChange = () => {},
    className,
    popoverProps,
    pickerCaptionProps = {},
    allowClear = true,
    monthLabel = MONTH_LABEL
  } = props,
      inputProps = _objectWithoutPropertiesLoose(props, _excluded);

  var [isOpen, setIsOpen] = useState(false);
  var [panelDate, setPanelDate] = useState(new Date());
  var [type, setType] = useState('month');
  var [date, setDate] = useState(props.value);
  useEffect(() => setDate(props.value), [props.value]);
  inputProps.value = useMemo(() => typeof date === 'string' ? date : date ? formatter(format, date) : '', [format, date]);

  if (allowClear && inputProps.value) {
    inputProps.addonAfter = /*#__PURE__*/_jsx(Button, {
      className: prefixCls + "-close-btn",
      icon: "close",
      onClick: () => {
        setDate('');
        onChange && onChange();
      },
      size: inputProps.size,
      basic: true,
      type: "light"
    });
  }

  function handleSelectedDate(type, num, paging) {
    var curPanelDate = new Date(new Date(panelDate)[type](num));

    if (!paging) {
      setType('month');
    }

    var curDate = formatter(format, new Date(curPanelDate));
    setDate(curDate);
    setPanelDate(curPanelDate);
    onChange && onChange(curPanelDate, curDate);

    if (type === 'setMonth') {
      setIsOpen(false);
    }
  }

  return /*#__PURE__*/_jsx(Popover, _extends({
    trigger: "focus",
    placement: "bottomLeft",
    autoAdjustOverflow: true,
    isOpen: isOpen
  }, popoverProps, {
    onVisibleChange: open => setIsOpen(open),
    content: /*#__PURE__*/_jsxs("div", {
      className: prefixCls + "-popover",
      children: [/*#__PURE__*/_jsx(DatePickerCaption, _extends({
        panelDate: panelDate,
        monthLabel: monthLabel
      }, pickerCaptionProps, {
        onSelected: captionType => {
          if (/^(month|year)$/.test(captionType)) {
            setType(captionType);
          } else {
            var year = new Date(panelDate).getFullYear();
            var curPanelDate = new Date(new Date(panelDate).setFullYear(type === 'next' ? year + 1 : year - 1));
            setPanelDate(curPanelDate);
          }
        }
      })), type === 'month' && /*#__PURE__*/_jsx(DatePickerMonth, {
        panelDate: panelDate,
        monthLabel: monthLabel,
        onSelected: (month, paging) => handleSelectedDate('setMonth', month, paging)
      }), type === 'year' && /*#__PURE__*/_jsx(DatePickerYear, {
        panelDate: panelDate,
        onSelected: (year, paging) => handleSelectedDate('setFullYear', year, paging)
      })]
    }),
    children: /*#__PURE__*/_jsx(Input, _extends({
      placeholder: "\u8BF7\u8F93\u5165\u65E5\u671F",
      readOnly: true
    }, inputProps, {
      className: [prefixCls, className].filter(Boolean).join(' ').trim()
    }))
  }));
}
//# sourceMappingURL=index.js.map